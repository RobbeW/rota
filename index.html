<!doctype html>

<!--Auteur: Robbe Wulgaert / aiindeklas.be-->
<!-- Copyright 2026 - Gebruik vrij voor educatie mits expliciete naamsvermelding -->

<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#5200FF" />
  <meta name="format-detection" content="telephone=no" />
  <title>Rota</title>

<link rel="icon" href="rota_app_icon.svg" type="image/svg+xml">
<link rel="icon" href="rota_app_icon.png" type="image/png" sizes="512x512">
<link rel="apple-touch-icon" href="rota_app_icon.png">
<meta name="theme-color" content="#5200FF">


<link rel="manifest" href="site.webmanifest">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Rota">

  <style>
    :root{
      --brand-purple:#5200FF;
      --brand-purple-dark:#3700B3;
      --brand-aqua:#3DFFD0;
      --brand-white:#FFFFFF;

      --bg:#F3F5F8;
      --panel:#F7F8FA;
      --ink:#23272E;
      --muted:#9AA3B2;

      --card:#FFFFFF;
      --border:#ECECF3;
      --shadow:0 2px 12px rgba(82,0,255,0.08);

      --topbar-h:70px;

      --p1: var(--brand-purple);
      --p2: var(--brand-aqua);

      --board-max: 620px;
      --tap: 44px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow-x:hidden;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
    }

    .topbar{
      position:sticky;
      top:0;
      z-index:50;
      height:var(--topbar-h);
      background:linear-gradient(180deg, #ffffff 0%, #fbfbfe 100%);
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      padding:0 16px;
      gap:14px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      line-height:1.05;
      min-width: 180px;
    }
    .brand .title{
      font-weight:900;
      letter-spacing:0.2px;
      color:var(--brand-purple);
      font-size:1.05rem;
    }
    .brand .subtitle{
      font-size:0.88rem;
      color:var(--muted);
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 300px;
    }

    .statusline{
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 12px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:999px;
      box-shadow:0 1px 10px rgba(0,0,0,0.03);
      font-size:0.95rem;
    }
    .pill b{ font-weight:900; }

    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--muted);
      box-shadow:0 0 0 3px rgba(0,0,0,0.04);
    }
    .dot.p1{ background:var(--p1); box-shadow:0 0 0 3px rgba(82,0,255,0.10); }
    .dot.p2{ background:var(--p2); box-shadow:0 0 0 3px rgba(61,255,208,0.20); }

    .btn{
      height:40px;
      padding:0 14px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      font-weight:900;
      color:var(--ink);
      box-shadow:0 1px 10px rgba(0,0,0,0.03);
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{
      border-color:transparent;
      background:var(--brand-purple);
      color:#fff;
      box-shadow:0 8px 24px rgba(82,0,255,0.18);
    }
    .btn.primary:hover{ background:var(--brand-purple-dark); }

    .main{
      flex:1;
      display:grid;
      grid-template-columns: 320px minmax(280px, 1fr) 320px;
      gap:16px;
      padding:16px;
      align-items:stretch;
    }

    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height: 360px;
      transition: opacity 160ms ease, filter 160ms ease;
    }

    .panel h3{
      margin:0;
      font-size:1.05rem;
      font-weight:900;
      color:var(--ink);
    }

    .playerCard{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      box-shadow:0 1px 10px rgba(0,0,0,0.03);
      display:flex;
      flex-direction:column;
      gap:10px;
      transition: opacity 160ms ease, filter 160ms ease, border-color 160ms ease;
    }
    .playerCard.active{
      border-color: rgba(82,0,255,0.28);
      box-shadow:0 10px 28px rgba(82,0,255,0.10);
    }
    .playerRow{
      display:flex;
      align-items:center;
      gap:10px;
      justify-content:space-between;
    }
    .playerName{
      font-weight:900;
      font-size:1.1rem;
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .playerName span{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 180px;
      display:inline-block;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      font-weight:900;
      font-size:0.9rem;
      background:#fff;
      white-space:nowrap;
    }

    .phaseBox{
      background:#fff;
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      line-height:1.45;
      font-size:0.98rem;
    }
    .phaseBox b{ font-weight:900; }
    .muted{ color:var(--muted); }

    /* Pucks indicator */
    .puckBlock{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .puckLabel{
      font-weight:900;
      color:var(--ink);
      font-size:0.95rem;
      white-space:nowrap;
    }
    .pucks{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .puck{
      width:14px;
      height:14px;
      border-radius:50%;
      border:2px solid var(--border);
      background:transparent;
      opacity:0.55;
    }
    .puck.available{
      opacity:1;
      border-color: rgba(0,0,0,0.0);
    }
    .puck.available.p1{ background:var(--p1); }
    .puck.available.p2{ background:var(--p2); }

    /* Board */
    .boardWrap{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:20px;
      box-shadow: var(--shadow);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      justify-content:center;
      min-height: 360px;
      position:relative;
    }

    .board{
      width:min(92vw, var(--board-max));
      aspect-ratio: 1 / 1;
      background:#fff;
      border:1px solid var(--border);
      border-radius:24px;
      box-shadow:0 10px 36px rgba(0,0,0,0.05);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      touch-action:manipulation;
    }

    svg{ width:100%; height:100%; display:block; }
    .svg-line{ stroke:#dad7f3; stroke-width:6; stroke-linecap:round; }
    .svg-circle{ fill:none; stroke:#e9e6fb; stroke-width:10; }

    .node{ cursor:pointer; transition: transform 120ms ease; }
    .node:hover{ transform: scale(1.02); }
    .node-hit{ fill:transparent; }
    .node-ring{ fill:#fff; stroke:#dfe3ea; stroke-width:4; }
    .node-ring.selectable{ stroke: var(--brand-purple); stroke-width:5; }
    .node-ring.selected{
      stroke: var(--brand-purple-dark);
      stroke-width:7;
      filter: drop-shadow(0 2px 10px rgba(82,0,255,0.25));
    }

    .piece{ pointer-events:none; }
    .piece.p1{ fill: var(--p1); }
    .piece.p2{ fill: var(--p2); }
    .pieceShadow{
      pointer-events:none;
      fill: rgba(0,0,0,0.10);
      transform: translate(2px,3px);
    }

    .hintRow{
      width:100%;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .hintRow .small{
      font-size:0.95rem;
      color:var(--muted);
      font-weight:800;
      line-height:1.35;
    }
    .hintStrong{
      color:var(--ink);
      font-weight:900;
    }

    /* Grey-out non-active player docks */
    body.turn-p1 #side-right,
    body.turn-p1 #tabletTop{ opacity:0.45; filter: grayscale(0.15); }
    body.turn-p2 #side-left,
    body.turn-p2 #tabletBottom{ opacity:0.45; filter: grayscale(0.15); }

    /* Micro-drill overlay */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.52);
      z-index:1200;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .overlay.active{ display:flex; }

    .overlayCard{
      width:min(720px, 98vw);
      background:#fff;
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow:0 24px 80px rgba(0,0,0,0.25);
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .overlayTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .overlayTop h2{
      margin:0;
      font-size:1.15rem;
      font-weight:900;
      color:var(--brand-purple);
    }
    .overlayTop .step{
      font-weight:900;
      color:var(--muted);
    }

    .promptBox{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .promptTitle{
      font-size:0.95rem;
      font-weight:900;
      color:var(--muted);
      letter-spacing:0.2px;
    }

    /* Prompt row with audio button */
    .promptRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .promptMain{
      font-size:1.35rem;
      font-weight:900;
      color:var(--ink);
      flex:1;
      min-width:0;
    }

    .audio-btn{
      width:42px;
      height:42px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 1px 10px rgba(0,0,0,0.03);
      flex:0 0 auto;
    }
    .audio-btn:active{ transform:translateY(1px); }
    .audio-btn:hover{ border-color:#d7d2fb; }
    .audio-btn svg{ width:20px; height:20px; fill: var(--brand-purple); }
    .audio-btn.playing{ outline: 3px solid rgba(82,0,255,0.16); border-color: transparent; }
    .audio-btn.small{ width:34px; height:34px; border-radius:10px; }
    .audio-btn.small svg{ width:18px; height:18px; }

    .hintToggleRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .hintBtn{
      border:1px solid var(--border);
      background:#fff;
      border-radius:12px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:900;
      color:var(--ink);
    }
    .hintBtn:active{ transform:translateY(1px); }
    .hintText{
      color:var(--muted);
      font-weight:800;
      line-height:1.35;
      display:none;
    }
    .hintText.visible{ display:block; }

    .choices{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .choice{
      border:1px solid var(--border);
      background:#fff;
      border-radius:14px;
      padding:12px;
      cursor:pointer;
      font-weight:900;
      line-height:1.25;
      min-height:54px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      box-shadow:0 1px 10px rgba(0,0,0,0.03);
    }
    .choice:hover{ border-color:#d7d2fb; }
    .choice.correct{ outline: 3px solid rgba(61,255,208,0.55); border-color: transparent; }
    .choice.wrong{ outline: 3px solid rgba(255, 77, 77, 0.45); }

    /* Choice with audio (mcq_response) */
    .choice.with-audio{
      justify-content:space-between;
      text-align:left;
      gap:10px;
    }
    .choice .choice-left{
      display:flex;
      flex-direction:column;
      gap:3px;
      align-items:flex-start;
      min-width:0;
      flex:1;
    }
    .choice .choice-left b{
      font-weight:900;
    }
    .choice .choice-audio{
      width:38px;
      height:38px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
      box-shadow:0 1px 10px rgba(0,0,0,0.02);
    }
    .choice .choice-audio:active{ transform:translateY(1px); }
    .choice .choice-audio svg{ width:18px; height:18px; fill: var(--brand-purple); }

    .inputRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .textInput{
      flex:1;
      min-width: 220px;
      height:44px;
      border-radius:12px;
      border:1px solid var(--border);
      padding:0 12px;
      font-size:1rem;
      font-weight:900;
      outline:none;
    }
    .textInput:focus{ border-color:#d7d2fb; box-shadow:0 0 0 4px rgba(82,0,255,0.08); }

    .overlayActions{
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .note{
      font-size:0.95rem;
      color:var(--muted);
      font-weight:800;
      line-height:1.35;
    }

    /* Word order drill */
    .tilesWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .tileRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      min-height: 48px;
      padding:10px;
      background:#fff;
      border:1px solid var(--border);
      border-radius:14px;
    }
    .tile{
      border:1px solid var(--border);
      background:#fff;
      border-radius:999px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:900;
      box-shadow:0 1px 10px rgba(0,0,0,0.02);
      user-select:none;
    }
    .tile:active{ transform:translateY(1px); }
    .tile.selected{
      opacity:0.45;
      cursor:default;
    }
    .tileTarget .tile{
      border-color:#d7d2fb;
    }

    /* Help button + modal */
    .help-btn{
      position:fixed;
      right:32px;
      bottom:32px;
      z-index:1500;
      background:var(--brand-purple);
      color:#fff;
      font-size:2em;
      border:none;
      border-radius:50%;
      width:54px;
      height:54px;
      cursor:pointer;
      box-shadow:0 2px 10px rgba(82,0,255,0.11);
    }
    .help-btn:hover{ background:var(--brand-purple-dark); }

    .help-modal{
      display:none;
      position:fixed;
      left:0; top:0; right:0; bottom:0;
      background:rgba(0,0,0,0.52);
      z-index:2000;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .help-modal.active{ display:flex !important; }

    .help-content{
      background:#fff;
      color:var(--ink);
      border-radius:14px;
      padding:2.0rem 1.8rem 1.4rem 1.8rem;
      width:960px;
      max-width:98vw;
      box-shadow:0 6px 40px rgba(82,0,255,0.17);
      position:relative;
      display:flex;
      gap:1.6rem;
      flex-direction:row;
      overflow-x:hidden; /* prevents odd horizontal scrollbars */
    }
    .help-left{ width:44%; min-width:240px; max-height:74vh; overflow-y:auto; }
    .help-right{ width:56%; min-width:240px; max-height:74vh; overflow-y:auto; }

    .help-content h2{
      color:var(--brand-purple);
      font-weight:900;
      margin-top:0;
      margin-bottom:0.7rem;
    }

    .close-help{
      position:absolute;
      top:0.9rem;
      right:0.9rem;
      background:none;
      border:none;
      font-size:1.05em;
      cursor:pointer;
      color:var(--ink);
      font-weight:900;
      padding:8px 10px;
      border-radius:12px;
    }
    .close-help:hover{ background:#f3f5f8; }

    .help-content ul{
      padding-left:1.2em;
      font-size:1.02em;
      line-height:1.5;
      margin:0;
    }

    .help-content table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      border:1px solid var(--border);
      border-radius:12px;
      overflow:hidden;
      background:#fff;
    }
    .help-content th, .help-content td{
      text-align:left;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      vertical-align:top;
      font-size:0.98em;
    }
    .help-content tr:last-child td{ border-bottom:none; }
    .help-content th{
      background:#f2f0fd;
      font-weight:900;
      color:var(--ink);
    }
    .help-hint{
      color:var(--muted);
      font-weight:800;
      font-size:0.95em;
      margin-top:10px;
      line-height:1.4;
    }

    .helpActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .select{
      height:40px;
      padding:0 12px;
      border-radius:12px;
      border:1px solid var(--border);
      font-weight:900;
      background:#fff;
      color:var(--ink);
      cursor:pointer;
    }

    .helpLatinCell{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* === PATCH: phone scaling for help modal (no overflow, stack columns) === */
    @media (max-width: 600px){
      .help-modal{
        padding:10px;
        align-items:flex-start;
        overflow:auto;
      }

      .help-content{
        width:100%;
        max-width:100%;
        flex-direction:column;
        gap:12px;
        padding:1.1rem 1.0rem 0.9rem 1.0rem;
        max-height:calc(100vh - 20px);
        overflow:auto;
        -webkit-overflow-scrolling:touch;
      }

      .help-left,
      .help-right{
        width:100%;
        min-width:0;
        max-height:none;
        overflow:visible;
      }

      .close-help{
        top:0.6rem;
        right:0.6rem;
      }
    }

    /* Layout modes */
    body.mode-desktop .main{ grid-template-columns: 320px minmax(280px, 1fr) 320px; }
    body.mode-desktop .tabletTop, body.mode-desktop .tabletBottom{ display:none; }

    body.mode-tablet .main{
      grid-template-columns: 1fr;
      padding:12px;
    }
    body.mode-tablet .panel.side{ display:none; }
    body.mode-tablet .boardWrap{ padding:12px; }
    body.mode-tablet .tabletTop,
    body.mode-tablet .tabletBottom{
      display:block;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: var(--shadow);
      padding:12px;
    }
    body.mode-tablet .tabletTop{ transform: rotate(180deg); }
    body.mode-tablet .tabletTop .playerCard{ transform: rotate(180deg); }
    body.mode-tablet .help-btn{
      right:18px;
      bottom:50%;
      transform: translateY(50%);
      width:54px;
      height:54px;
    }

    body.mode-phone .main{
      grid-template-columns: 1fr;
      padding:10px;
      gap:10px;
    }
    body.mode-phone .panel.side{ display:none; }
    body.mode-phone .boardWrap{ padding:10px; border-radius:18px; }
    body.mode-phone .board{ border-radius:18px; }
    body.mode-phone .help-btn{
      right:14px;
      bottom:14px;
      width:48px;
      height:48px;
      font-size:1.7em;
    }
    body.mode-phone .brand{ min-width: 140px; }
    body.mode-phone .brand .subtitle{ display:none; }
    body.mode-phone .pill{ padding:7px 10px; font-size:0.92rem; }

    .tabletTop, .tabletBottom{ display:none; }

    .sr-only{
      position:absolute;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden;clip:rect(0,0,0,0);
      border:0;
    }
  </style>
</head>

<body>

  <script id="rota-yaml" type="text/plain">
meta:
  project: "Rota"
  purpose: "1v1 Rota-spel dat een klein setje Latijnse zinnen inoefent via korte micro-oefeningen (start/einde)."
  audience: "Beginners (secundair onderwijs)"
  ui_language: "nl"
  latin_level: "very_light"
  version: "1.1"

theme:
  colors:
    primary:   "#5200FF"
    secondary: "#3DFFD0"
    purple_dark: "#3700B3"
    white: "#FFFFFF"
    bg: "#F3F5F8"
    panel: "#F7F8FA"
    ink: "#23272E"
    muted: "#9AA3B2"
    card: "#FFFFFF"
    border: "#ECECF3"
  shadow: "0 2px 12px rgba(82,0,255,0.08)"
  layout:
    topbar_h_px: 70

game:
  name: "Rota"
  tagline: "Romeins strategie-spel met 3 stukken per speler."
  background:
    short: >
      Rota (Latijn: “wiel”) is een oud bordspel uit de oudheid.
      Je plaatst eerst je drie stukken, daarna schuif je telkens één stap langs een getekende verbinding.
    rules_summary:
      pieces_per_player: 3
      phases:
        - id: "placement"
          description: "Om beurten plaats je één stuk op een leeg punt tot iedereen 3 stukken heeft."
        - id: "movement"
          description: "Daarna verplaats je om beurten één stuk naar een direct verbonden leeg punt (exact één stap)."
      movement_rule: "Verplaats precies één stap naar een verbonden leeg punt (niet springen)."
      win_condition: "Wie als eerste drie op een rij maakt door het midden, wint."
  players:
    - id: "p1"
      label: "Speler 1"
      color: "#5200FF"
    - id: "p2"
      label: "Speler 2"
      color: "#3DFFD0"
  ui_hooks:
    show_rule_overlay_on_first_launch: true
    show_phase_indicator: true
    show_three_in_row_hint: true

latin_learning:
  goal: "Korte, onvermijdbare micro-oefeningen: start + einde. Tijdens het spel: lookup in de hulp."
  phrases:
    - id: "salve"
      latin: "Salve!"
      english: "Hello! (singular)"
      drill_modes: ["mcq_match", "tap_to_confirm"]

    - id: "mihi_nomen_est"
      latin: "Mihi nomen est …"
      english: "My name is …"
      drill_modes: ["fill_blank_name"]

    - id: "quid_agis"
      latin: "Quid agis?"
      english: "How are you?"
      drill_modes: ["mcq_response"]

    - id: "bene_mihi_est"
      latin: "Bene mihi est."
      english: "I’m well."
      drill_modes: ["choice_button", "word_order"]

    - id: "male_mihi_est"
      latin: "Male mihi est."
      english: "I’m not well."
      drill_modes: ["choice_button", "word_order"]

    - id: "et_tibi"
      latin: "Et tibi?"
      english: "And you?"
      drill_modes: ["tap_to_confirm", "word_order"]

    - id: "paratus_es_m"
      latin: "Paratus es?"
      english: "Are you ready? (to a boy)"
      drill_modes: ["mcq_match"]

    - id: "parata_es_f"
      latin: "Parata es?"
      english: "Are you ready? (to a girl)"
      drill_modes: ["mcq_match"]

    - id: "ego_paratus_sum"
      latin: "Ego paratus sum."
      english: "I’m ready. (boy speaking)"
      drill_modes: ["word_order"]

    - id: "ego_parata_sum"
      latin: "Ego parata sum."
      english: "I’m ready. (girl speaking)"
      drill_modes: ["word_order"]

    # === PATCH: keep id-based naming for audio and sequences ===
    # id stays "finis_ludi" (used for audio filename: finis_ludi.mp3)
    # diacritics only in display text
    - id: "finis_ludi"
      latin: "Finis lūdī."
      english: "End of the game."
      drill_modes: ["tap_to_confirm"]

    - id: "vinco"
      latin: "Vinco!"
      english: "I win!"
      drill_modes: ["mcq_match", "tap_to_confirm"]

    - id: "vincis"
      latin: "Vincis!"
      english: "You win!"
      drill_modes: ["mcq_match", "tap_to_confirm"]

  ui_integration:
    pre_match_sequence:
      max_steps: 4
      steps:
        - phrase_id: "salve"
          drill: { type: "mcq_match" }
        - phrase_id: "mihi_nomen_est"
          drill: { type: "fill_blank_name", input_key: "player_name" }
        - phrase_id: "quid_agis"
          drill: { type: "mcq_response", prompt_phrase_id: "quid_agis", options_phrase_ids: ["bene_mihi_est", "male_mihi_est"] }
        - phrase_id: "et_tibi"
          drill: { type: "word_order" }

    post_match_sequence:
      steps:
        - phrase_id: "finis_ludi"
          drill: { type: "read_aloud" }
        - outcome_branch:
            winner:
              phrase_id: "vinco"
              drill: { type: "mcq_match" }
            loser:
              phrase_id: "vincis"
              drill: { type: "mcq_match" }

  practice_engine:
    spaced_repetition:
      buckets: ["new", "learning", "known"]
      promote_rule:
        correct_streak_to_promote: 3
      demote_rule:
        wrong_to_demote: 1
    session_limits:
      max_total_drills_per_match: 6
      max_seconds_per_drill: 12
    persistence:
      store_key: "rota_latin_progress_v1"
      per_phrase_fields: ["seen", "correct", "wrong", "streak", "bucket", "last_seen_iso"]

assets:
  audio:
    enabled: true
    base_path: "./media/"
    naming: "{id}.mp3"
    files: []
  </script>

  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="title" id="brand-title">Rota</div>
      </div>

      <div class="statusline">
        <div class="pill" id="pill-turn">
          <span class="dot" id="turn-dot"></span>
          <span><b>Aan zet:</b> <span id="turn-name">—</span></span>
        </div>
        <button class="btn" id="btn-reset" type="button">Nieuw spel</button>
      </div>
    </header>

    <section class="tabletTop" id="tabletTop">
      <div class="playerCard" id="t-card-p2">
        <div class="playerRow">
          <div class="playerName">
            <span class="dot p2"></span>
            <span id="t-p2-name">Speler 2</span>
          </div>
          <div class="badge" id="t-p2-badge">—</div>
        </div>

        <div class="puckBlock">
          <div class="puckLabel">Stukken over</div>
          <div class="pucks" id="t-p2-pucks" aria-label="Stukken over speler 2"></div>
        </div>

        <div class="phaseBox">
          <b>Schuiven = 1 stap:</b> alleen naar een <span class="hintStrong">direct verbonden</span> leeg punt.
        </div>
      </div>
    </section>

    <main class="main">
      <!-- Left side (desktop) -->
      <aside class="panel side" id="side-left">
        <h3>Speler 1</h3>
        <div class="playerCard" id="card-p1">
          <div class="playerRow">
            <div class="playerName">
              <span class="dot p1"></span>
              <span id="p1-name">Speler 1</span>
            </div>
            <div class="badge" id="p1-badge">—</div>
          </div>

          <div class="puckBlock">
            <div class="puckLabel">Stukken over</div>
            <div class="pucks" id="p1-pucks" aria-label="Stukken over speler 1"></div>
          </div>

          <div class="phaseBox">
            <b>Doel:</b> drie op een rij door het midden.<br>
            <span class="muted">Na het plaatsen: schuif <b>exact één stap</b> naar een verbonden leeg punt.</span>
          </div>
        </div>

        <h3>Spelinfo</h3>
        <div class="phaseBox" id="rules-box">
          <div class="muted" id="rules-short">—</div>
          <div style="height:8px"></div>
          <b>Zet:</b> <span id="rules-move">—</span><br>
          <b>Winnen:</b> <span id="rules-win">—</span>
        </div>
      </aside>

      <!-- Center -->
      <section class="boardWrap" aria-label="Rota bord">
        <div class="board" id="board" role="application" aria-label="Rota speelveld">
          <svg viewBox="0 0 400 400" aria-hidden="true">
            <circle class="svg-circle" cx="200" cy="200" r="150"></circle>

            <line class="svg-line" x1="200" y1="50" x2="200" y2="350"></line>
            <line class="svg-line" x1="50" y1="200" x2="350" y2="200"></line>
            <line class="svg-line" x1="94" y1="94" x2="306" y2="306"></line>
            <line class="svg-line" x1="306" y1="94" x2="94" y2="306"></line>

            <g id="nodes"></g>
            <g id="pieces"></g>
          </svg>
        </div>

        <div class="hintRow">
          <div class="small" id="actionHint">—</div>
          <div class="small" id="threeHint">—</div>
        </div>
      </section>

      <!-- Right side (desktop) -->
      <aside class="panel side" id="side-right">
        <h3>Speler 2</h3>
        <div class="playerCard" id="card-p2">
          <div class="playerRow">
            <div class="playerName">
              <span class="dot p2"></span>
              <span id="p2-name">Speler 2</span>
            </div>
            <div class="badge" id="p2-badge">—</div>
          </div>

          <div class="puckBlock">
            <div class="puckLabel">Stukken over</div>
            <div class="pucks" id="p2-pucks" aria-label="Stukken over speler 2"></div>
          </div>

          <div class="phaseBox">
            <b>Schuiven = 1 stap:</b> alleen naar een <span class="hintStrong">direct verbonden</span> leeg punt.<br>
            <span class="muted">Tip: blokkeer lijnen door het midden.</span>
          </div>
        </div>

        <h3>Latijn</h3>
        <div class="phaseBox">
          <b>Kleine oefeningen:</b> Aan de start en het einde van het spel.<br>
          <span class="muted">Wil je meer oefeningen? Alle zinnen en extra uitdagingen vind je via de <b>?-knop</b>.</span>
        </div>
      </aside>
    </main>

    <!-- Tablet tabletop: bottom player indicator (speler 1) -->
    <section class="tabletBottom" id="tabletBottom">
      <div class="playerCard" id="t-card-p1">
        <div class="playerRow">
          <div class="playerName">
            <span class="dot p1"></span>
            <span id="t-p1-name">Speler 1</span>
          </div>
          <div class="badge" id="t-p1-badge">—</div>
        </div>

        <div class="puckBlock">
          <div class="puckLabel">Stukken over</div>
          <div class="pucks" id="t-p1-pucks" aria-label="Stukken over speler 1"></div>
        </div>

        <div class="phaseBox">
          <b>Doel:</b> drie op een rij door het midden.<br>
          <span class="muted">Na plaatsen: schuif <b>1 stap</b> naar een verbonden leeg punt.</span>
        </div>
      </div>
    </section>
  </div>

  <!-- Help button -->
  <button id="help-btn" class="help-btn" type="button" aria-label="Hulp">?</button>

  <!-- Help modal -->
  <div id="help-modal" class="help-modal" role="dialog" aria-modal="true" aria-labelledby="help-title">
    <div class="help-content" role="document">
      <button id="close-help" class="close-help" type="button">Sluiten ✕</button>

      <div class="help-left">
        <h2 id="help-title">Hulp</h2>
        <h3 style="margin:0 0 6px 0;font-weight:900;">Hoe speel je Rota?</h3>
        <div id="help-howto"></div>
        <div class="help-hint" id="help-culture"></div>

        <div class="helpActions">
          <select class="select" id="mode-select" aria-label="Weergave kiezen">
            <option value="auto">Weergave: automatisch</option>
            <option value="desktop">Weergave: laptop/pc</option>
            <option value="tablet">Weergave: tablet (tafel)</option>
            <option value="phone">Weergave: telefoon</option>
          </select>

          <button class="btn" id="btn-printable" type="button">Maak printbare versie</button>
        </div>
      </div>

      <div class="help-right">
        <h2>Latijnse zinnen</h2>
        <div class="helpActions" style="margin-top:-4px;">
          <button class="btn primary" id="btn-practice" type="button">Oefen een zin</button>
        </div>
        <div style="height:10px"></div>
        <div id="help-latin"></div>
      </div>
    </div>
  </div>

  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-labelledby="overlay-title">
    <div class="overlayCard" role="document">
      <div class="overlayTop">
        <h2 id="overlay-title">Latijn</h2>
        <div class="step" id="overlay-step">—</div>
      </div>

      <div class="promptBox">
        <div class="promptTitle" id="promptTitle">—</div>

        <div class="promptRow">
          <div class="promptMain" id="promptMain">—</div>
          <button class="audio-btn" id="btn-audio" type="button" aria-label="Luister naar uitspraak"></button>
        </div>

        <div class="hintToggleRow">
          <div class="hintText" id="promptHint"></div>
          <button class="hintBtn" id="btn-hint" type="button">Toon hint</button>
        </div>
      </div>

      <div id="overlay-body"></div>

      <div class="overlayActions">
        <div class="note" id="overlay-note">—</div>
        <button class="btn primary" id="overlay-next" type="button">Verder</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    function setText(el, txt){ if (el) el.textContent = txt; }
    function setHTML(el, html){ if (el) el.innerHTML = html; }
    function setToggle(el, cls, on){ if (el) el.classList.toggle(cls, !!on); }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[m]));
    }

    const NL_GLOSS = {
      salve: "Hallo (enkelvoud).",
      mihi_nomen_est: "Mijn naam is …",
      quid_agis: "Hoe gaat het?",
      bene_mihi_est: "Het gaat goed met mij.",
      male_mihi_est: "Het gaat niet goed met mij.",
      et_tibi: "En met jou?",
      paratus_es_m: "Ben je klaar? (tegen een jongen)",
      parata_es_f: "Ben je klaar? (tegen een meisje)",
      ego_paratus_sum: "Ik ben klaar. (jongen spreekt)",
      ego_parata_sum: "Ik ben klaar. (meisje spreekt)",
      finis_ludi: "Einde van het spel.",
      vinco: "Ik win!",
      vincis: "Jij wint!"
    };

    const UI_TEXT = {
      phase_placement: "plaatsen",
      phase_movement: "schuiven",
      hint_place: "Plaatsen: klik op een leeg punt om een stuk te plaatsen.",
      hint_select: "Schuiven: klik op jouw stuk, klik dan op een verbonden leeg punt (1 stap).",
      hint_move: "Kies een bestemming: alleen 1 stap naar een verbonden leeg punt.",
      hint_win: "Winnen: drie op een rij door het midden.",
      overlay_gate: "Start",
      overlay_end: "Einde",
      overlay_practice: "Oefenen"
    };

    function loadCfgFromYaml(){
      const raw = document.getElementById('rota-yaml').textContent.trim();
      const cfg = jsyaml.load(raw) || {};

      const phrases = cfg?.latin_learning?.phrases || [];
      for (const p of phrases){
        if (!p) continue;
        p.nl = p.nl || NL_GLOSS[p.id] || "";
      }

      cfg.latin_learning ||= {};
      cfg.latin_learning.practice_engine ||= {};
      cfg.latin_learning.practice_engine.persistence ||= { store_key:"rota_latin_progress_v1" };

      return cfg;
    }

    const CFG = loadCfgFromYaml();
    window.ROTA_CFG = CFG;

    function applyTheme(cfg){
      const c = cfg?.theme?.colors || {};
      const root = document.documentElement.style;

      if (c.primary) root.setProperty('--brand-purple', c.primary);
      if (c.secondary) root.setProperty('--brand-aqua', c.secondary);
      if (c.purple_dark) root.setProperty('--brand-purple-dark', c.purple_dark);

      if (c.white) root.setProperty('--brand-white', c.white);
      if (c.bg) root.setProperty('--bg', c.bg);
      if (c.panel) root.setProperty('--panel', c.panel);
      if (c.ink) root.setProperty('--ink', c.ink);
      if (c.muted) root.setProperty('--muted', c.muted);
      if (c.card) root.setProperty('--card', c.card);
      if (c.border) root.setProperty('--border', c.border);

      if (cfg?.theme?.shadow) root.setProperty('--shadow', cfg.theme.shadow);
      if (cfg?.theme?.layout?.topbar_h_px) root.setProperty('--topbar-h', cfg.theme.layout.topbar_h_px + "px");

      const p1 = cfg?.game?.players?.[0]?.color || c.primary;
      const p2 = cfg?.game?.players?.[1]?.color || c.secondary;
      if (p1) root.setProperty('--p1', p1);
      if (p2) root.setProperty('--p2', p2);

      setText(document.getElementById('brand-title'), cfg?.meta?.project || "Rota");
      setText(document.getElementById('brand-subtitle'), "Romeins strategie-spel + mini-Latijn");
    }
    applyTheme(CFG);

    const AUDIO_CFG = {
      enabled: !!(CFG?.assets?.audio?.enabled),
      basePath: String(CFG?.assets?.audio?.base_path || "./media/"),
      naming: String(CFG?.assets?.audio?.naming || "{id}.mp3")
    };

    const AUDIO_ICON_SVG = `
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 10v4c0 .55.45 1 1 1h3l4.5 3.6c.66.53 1.5.06 1.5-.75V5.15c0-.81-.84-1.28-1.5-.75L7 8H4c-.55 0-1 .45-1 1zm14.5 2c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03zM15 3.23v2.06c2.89 1 5 3.77 5 6.71s-2.11 5.71-5 6.71v2.06c4.01-1.06 7-4.7 7-8.77s-2.99-7.71-7-8.77z"/>
      </svg>
    `;

    const audioCache = new Map();
    let currentAudio = null;
    let currentAudioBtn = null;

    function getPhraseById(id){
      return (CFG?.latin_learning?.phrases || []).find(p => p.id === id) || null;
    }

    function phraseAudioFile(phrase){
      if (!phrase) return null;
      if (phrase.audio_file) return String(phrase.audio_file).trim();
      return AUDIO_CFG.naming.replace("{id}", phrase.id) || (phrase.id + ".mp3");
    }

    function audioUrlForPhraseId(phraseId){
      if (!AUDIO_CFG.enabled) return null;
      const p = getPhraseById(phraseId);
      const file = phraseAudioFile(p);
      if (!file) return null;
      const base = AUDIO_CFG.basePath.endsWith("/") ? AUDIO_CFG.basePath : (AUDIO_CFG.basePath + "/");
      return base + file;
    }

    async function playAudioUrl(url, btnEl){
      if (!url) return;

      if (currentAudio){
        try{ currentAudio.pause(); currentAudio.currentTime = 0; }catch(e){}
        currentAudio = null;
      }
      if (currentAudioBtn){
        currentAudioBtn.classList.remove("playing");
        currentAudioBtn = null;
      }

      let a = audioCache.get(url);
      if (!a){
        a = new Audio(url);
        a.preload = "auto";
        audioCache.set(url, a);
      }

      currentAudio = a;
      currentAudioBtn = btnEl || null;
      if (currentAudioBtn) currentAudioBtn.classList.add("playing");

      a.onended = () => {
        if (currentAudioBtn) currentAudioBtn.classList.remove("playing");
        currentAudio = null;
        currentAudioBtn = null;
      };

      try{
        await a.play();
      }catch(e){
        if (currentAudioBtn) currentAudioBtn.classList.remove("playing");
        currentAudio = null;
        currentAudioBtn = null;
        console.warn("Audio play blocked/missing:", url, e);
      }
    }

    function wireAudioButton(btnEl, phraseId){
      if (!btnEl) return;

      btnEl.innerHTML = AUDIO_ICON_SVG;

      if (!AUDIO_CFG.enabled || !phraseId){
        btnEl.style.display = "none";
        btnEl.onclick = null;
        return;
      }

      const url = audioUrlForPhraseId(phraseId);
      btnEl.style.display = url ? "" : "none";

      btnEl.onclick = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const u = audioUrlForPhraseId(phraseId);
        await playAudioUrl(u, btnEl);
      };
    }

    const MODE_KEY = "rota_mode_override_v1";

    function getModeOverride(){
      try{ return localStorage.getItem(MODE_KEY) || "auto"; }catch(e){ return "auto"; }
    }
    function setModeOverride(v){
      try{ localStorage.setItem(MODE_KEY, v); }catch(e){}
    }

    function applyModeClass(mode){
      document.body.classList.remove('mode-desktop','mode-tablet','mode-phone');

      if (mode === "phone") document.body.classList.add('mode-phone');
      else if (mode === "tablet") document.body.classList.add('mode-tablet');
      else if (mode === "desktop") document.body.classList.add('mode-desktop');
      else {
        const w = Math.min(window.innerWidth, window.screen?.width || window.innerWidth);
        const h = Math.min(window.innerHeight, window.screen?.height || window.innerHeight);
        const portrait = h >= w;

        if (w <= 599) document.body.classList.add('mode-phone');
        else if (w <= 1024) document.body.classList.add('mode-tablet');
        else document.body.classList.add('mode-desktop');

        const root = document.documentElement.style;
        if (document.body.classList.contains('mode-phone')) root.setProperty('--board-max', '420px');
        else if (document.body.classList.contains('mode-tablet')) root.setProperty('--board-max', portrait ? '520px' : '620px');
        else root.setProperty('--board-max', '620px');
      }
    }

    function setModeClass(){
      applyModeClass(getModeOverride());
    }
    window.addEventListener('resize', setModeClass);
    setModeClass();

    const STORE_KEY = CFG?.latin_learning?.practice_engine?.persistence?.store_key || "rota_latin_progress_v1";
    function nowIso(){ return new Date().toISOString(); }

    function loadProgress(){
      try{
        const raw = localStorage.getItem(STORE_KEY);
        if (!raw) return {};
        return JSON.parse(raw) || {};
      }catch(e){ return {}; }
    }
    function saveProgress(p){
      try{ localStorage.setItem(STORE_KEY, JSON.stringify(p)); }catch(e){}
    }
    function ensurePhraseProgress(progress, phraseId){
      progress[phraseId] ||= { seen:0, correct:0, wrong:0, streak:0, bucket:"new", last_seen_iso:null };
      return progress[phraseId];
    }
    function markSeen(progress, phraseId){
      const pr = ensurePhraseProgress(progress, phraseId);
      pr.seen += 1;
      pr.last_seen_iso = nowIso();
      return pr;
    }
    function markResult(progress, phraseId, isCorrect){
      const pr = ensurePhraseProgress(progress, phraseId);
      if (isCorrect){
        pr.correct += 1;
        pr.streak += 1;
        if (pr.streak >= 3) pr.bucket = "known";
        else pr.bucket = (pr.bucket === "new") ? "learning" : pr.bucket;
      } else {
        pr.wrong += 1;
        pr.streak = 0;
        pr.bucket = "learning";
      }
      pr.last_seen_iso = nowIso();
      return pr;
    }
    function mastery(progress, phraseId){
      const pr = ensurePhraseProgress(progress, phraseId);
      const total = pr.correct + pr.wrong;
      if (total <= 0) return 0;
      return pr.correct / total;
    }

    const helpBtn  = document.getElementById('help-btn');
    const helpModal= document.getElementById('help-modal');
    const closeHelp= document.getElementById('close-help');
    const helpHowto= document.getElementById('help-howto');
    const helpLatin= document.getElementById('help-latin');
    const helpCulture = document.getElementById('help-culture');
    const modeSelect = document.getElementById('mode-select');

    let lastFocus = null;

    function renderHowTo(cfg){
      const rs = cfg?.game?.background?.rules_summary || {};
      const phases = Array.isArray(rs.phases) ? rs.phases : [];

      const items = [];
      items.push(`<li><b>Stukken per speler:</b> ${escapeHtml(rs.pieces_per_player ?? 3)}</li>`);

      if (phases.length){
        const phaseLis = phases.map(p => {
          const id = (p.id === "placement") ? "plaatsen" : (p.id === "movement" ? "schuiven" : p.id);
          return `<li><b>${escapeHtml(id)}:</b> ${escapeHtml(p.description || "")}</li>`;
        }).join('');
        items.push(`<li><b>Fases:</b><ul>${phaseLis}</ul></li>`);
      }

      items.push(`<li><b>Zet:</b> ${escapeHtml(rs.movement_rule || "")}</li>`);
      items.push(`<li><b>Winnen:</b> ${escapeHtml(rs.win_condition || "")}</li>`);

      return `<ul>${items.join('')}</ul>`;
    }

    function renderLatinTable(cfg){
      const phrases = cfg?.latin_learning?.phrases || [];
      const rows = phrases.map(p => {
        const audioBtn = AUDIO_CFG.enabled
          ? `<button class="audio-btn small" type="button" data-audio="${escapeHtml(p.id)}" aria-label="Luister"></button>`
          : "";

        return `
          <tr>
            <td>
              <div class="helpLatinCell">
                <b>${escapeHtml(p.latin || "")}</b>
                ${audioBtn}
              </div>
            </td>
            <td>${escapeHtml(p.nl || "")}</td>
          </tr>
        `;
      }).join('');

      return `
        <table>
          <thead>
            <tr>
              <th>Latijn</th>
              <th>Betekenis</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>`;
    }

    function openHelp(){
      setHTML(helpHowto, renderHowTo(CFG));
      setHTML(helpLatin, renderLatinTable(CFG));
      const bg = CFG?.game?.background?.short || "";
      setHTML(helpCulture, bg ? `<b>Achtergrond:</b> ${escapeHtml(bg)}` : "");

      if (AUDIO_CFG.enabled && helpLatin){
        helpLatin.querySelectorAll('button[data-audio]').forEach(b => { b.innerHTML = AUDIO_ICON_SVG; });
      }

      const ov = getModeOverride();
      if (modeSelect) modeSelect.value = ov;

      lastFocus = document.activeElement;
      helpModal.classList.add('active');
      closeHelp.focus();
    }

    function closeHelpModal(){
      helpModal.classList.remove('active');
      if (lastFocus && typeof lastFocus.focus === 'function') lastFocus.focus();
    }

    helpBtn.addEventListener('click', openHelp);
    closeHelp.addEventListener('click', closeHelpModal);
    helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelpModal(); });
    document.addEventListener('keydown', (e) => {
      if (!helpModal.classList.contains('active')) return;
      if (e.key === 'Escape') closeHelpModal();
    });

    if (modeSelect){
      modeSelect.addEventListener('change', () => {
        const v = modeSelect.value || "auto";
        setModeOverride(v);
        setModeClass();
      });
    }

    helpLatin?.addEventListener('click', async (e) => {
      const btn = e.target.closest('button[data-audio]');
      if (!btn) return;
      e.preventDefault();
      e.stopPropagation();
      const pid = btn.getAttribute('data-audio');
      await playAudioUrl(audioUrlForPhraseId(pid), btn);
    });

    const btnPrintable = document.getElementById('btn-printable');

    function buildPrintablePdf(){
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: "mm", format: "a4", orientation: "portrait" });

      const W = doc.internal.pageSize.getWidth();
      const H = doc.internal.pageSize.getHeight();
      const margin = 12;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(18);
      doc.text("Rota — printversie", margin, 16);

      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      doc.text("Speel offline met het bord hieronder. Noteer namen en gebruik de zinnenlijst.", margin, 22);

      doc.setFont("helvetica", "bold");
      doc.setFontSize(11);
      doc.text("Speler 1:", margin, 32);
      doc.line(margin + 20, 32, margin + 88, 32);

      doc.text("Speler 2:", margin + 95, 32);
      doc.line(margin + 115, 32, W - margin, 32);

      const r  = 45;
      const cx = W / 2;
      const nameY = 32;
      const gapAfterNames = 14;
      const boardTop = nameY + gapAfterNames;
      const cy = boardTop + r;
      const boardBottom = cy + r;

      doc.setLineWidth(0.6);
      doc.circle(cx, cy, r);

      doc.setLineWidth(0.5);
      doc.line(cx, cy - r, cx, cy + r);
      doc.line(cx - r, cy, cx + r, cy);

      const d = r * Math.SQRT1_2;
      doc.line(cx - d, cy - d, cx + d, cy + d);
      doc.line(cx + d, cy - d, cx - d, cy + d);

      const pts = [];
      for (let i = 0; i < 8; i++){
        const ang = (-90 + i * 45) * Math.PI / 180;
        pts.push({ x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) });
      }
      pts.push({ x: cx, y: cy });

      doc.setLineWidth(0.4);
      for (const p of pts) doc.circle(p.x, p.y, 2);

      let y = Math.max(124, boardBottom + 14);
      doc.setFont("helvetica", "bold");
      doc.setFontSize(12);
      doc.text("Kernregels", margin, y);
      y += 6;

      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      const rules = [
        "1) Plaatsen: om beurten plaats je één stuk op een leeg punt tot iedereen 3 stukken heeft.",
        "2) Schuiven: verplaats om beurten één stuk naar een direct verbonden leeg punt (exact één stap).",
        "3) Winnen: drie op een rij door het midden."
      ];
      for (const line of rules){
        doc.text(line, margin, y);
        y += 5;
      }

      y += 4;
      doc.setFont("helvetica", "bold");
      doc.setFontSize(12);
      doc.text("Latijnse zinnen", margin, y);
      y += 6;

      const phrases = (CFG?.latin_learning?.phrases || []).map(p => ({
        latin: String(p.latin || "").trim(),
        nl: String(p.nl || "").trim()
      })).filter(x => x.latin && x.nl);

      const col1 = margin;
      const col2 = margin + 70;
      const rowH = 6;
      const maxY = H - 16;

      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      doc.text("Latijn", col1, y);
      doc.text("Betekenis", col2, y);
      y += 3;
      doc.setLineWidth(0.3);
      doc.line(margin, y, W - margin, y);
      y += 4;

      doc.setFont("helvetica", "normal");
      for (const p of phrases){
        if (y + rowH > maxY){
          doc.addPage();
          y = 16;

          doc.setFont("helvetica", "bold");
          doc.setFontSize(10);
          doc.text("Latijn", col1, y);
          doc.text("Betekenis", col2, y);
          y += 3;
          doc.line(margin, y, W - margin, y);
          y += 4;
          doc.setFont("helvetica", "normal");
        }
        doc.text(p.latin, col1, y);
        doc.text(p.nl, col2, y);
        y += rowH;
      }

      doc.setFont("helvetica", "normal");
      doc.setFontSize(9);
      doc.text("© 2026 Robbe Wulgaert · aiindeklas.be", margin, H - 8);

      return doc;
    }

    btnPrintable?.addEventListener('click', () => {
      try{
        const doc = buildPrintablePdf();
        doc.save("rota-printversie.pdf");
      }catch(e){
        alert("PDF maken mislukt. Controleer of jsPDF geladen is.");
      }
    });

    const nodesG  = document.getElementById('nodes');
    const piecesG = document.getElementById('pieces');

    const PTS = (() => {
      const cx = 200, cy = 200, r = 150;
      const pts = [];
      for (let i=0;i<8;i++){
        const ang = (-90 + i*45) * Math.PI/180;
        pts.push({ id:i, x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang) });
      }
      pts.push({ id:8, x: cx, y: cy });
      return pts;
    })();

    const ADJ = (() => {
      const a = {};
      for (let i=0;i<8;i++){
        a[i] = new Set([ (i+1)%8, (i+7)%8, 8 ]);
      }
      a[8] = new Set([0,1,2,3,4,5,6,7]);
      return a;
    })();

    const WIN_LINES = [
      [0,8,4],
      [2,8,6],
      [1,8,5],
      [7,8,3]
    ];

    const state = {
      phase: "placement",
      current: "p1",
      pieces: {},
      placed: { p1:0, p2:0 },
      selected: null,
      locked: true,
      winner: null,
      names: { p1:"Speler 1", p2:"Speler 2" },
      drillsUsedThisMatch: 0,
      maxDrills: CFG?.latin_learning?.practice_engine?.session_limits?.max_total_drills_per_match ?? 6,
      lastPhase: null
    };

    function otherPlayer(p){ return p === "p1" ? "p2" : "p1"; }
    function pointEmpty(pid){ return !state.pieces[pid]; }
    function inPlacementDone(){ return state.placed.p1 >= 3 && state.placed.p2 >= 3; }

    function updatePhase(){
      const newPhase = inPlacementDone() ? "movement" : "placement";
      state.phase = newPhase;
    }

    function checkWinner(){
      for (const line of WIN_LINES){
        const [a,b,c] = line;
        const pa = state.pieces[a];
        if (!pa) continue;
        if (state.pieces[b] === pa && state.pieces[c] === pa){
          state.winner = pa;
          return pa;
        }
      }
      return null;
    }

    function selectableDestinations(fromPid){
      const s = ADJ[fromPid];
      if (!s) return [];
      return [...s].filter(pid => pointEmpty(pid));
    }

    function canMove(fromPid, toPid){
      if (!ADJ[fromPid] || !ADJ[fromPid].has(toPid)) return false;
      if (!pointEmpty(toPid)) return false;
      return true;
    }

    function placePiece(pid){
      if (state.phase !== "placement") return false;
      if (!pointEmpty(pid)) return false;
      if (state.placed[state.current] >= 3) return false;

      state.pieces[pid] = state.current;
      state.placed[state.current] += 1;

      updatePhase();
      checkWinner();

      if (!state.winner) state.current = otherPlayer(state.current);
      return true;
    }

    function movePiece(fromPid, toPid){
      if (state.phase !== "movement") return false;
      if (state.pieces[fromPid] !== state.current) return false;
      if (!canMove(fromPid, toPid)) return false;

      delete state.pieces[fromPid];
      state.pieces[toPid] = state.current;

      state.selected = null;
      checkWinner();

      if (!state.winner) state.current = otherPlayer(state.current);
      return true;
    }

    function resetState(){
      state.phase = "placement";
      state.current = "p1";
      state.pieces = {};
      state.placed = { p1:0, p2:0 };
      state.selected = null;
      state.winner = null;
      state.locked = true;
      state.drillsUsedThisMatch = 0;
      state.lastPhase = null;
      renderAll();
    }

    function clearSvgGroup(g){ while (g.firstChild) g.removeChild(g.firstChild); }

    function mk(tag, attrs){
      const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
      for (const k in attrs) el.setAttribute(k, attrs[k]);
      return el;
    }

    function drawNodes(){
      clearSvgGroup(nodesG);
      for (const p of PTS){
        const g = mk('g', { class:'node', 'data-id': p.id });
        const ring = mk('circle', { class:'node-ring', cx:p.x, cy:p.y, r:16 });
        const hit  = mk('circle', { class:'node-hit', cx:p.x, cy:p.y, r:26 });
        g.appendChild(ring);
        g.appendChild(hit);

        g.addEventListener('click', () => onNodeClick(p.id));
        g.addEventListener('touchend', (e) => { e.preventDefault(); onNodeClick(p.id); }, { passive:false });

        nodesG.appendChild(g);
      }
    }

    function drawPieces(){
      clearSvgGroup(piecesG);
      for (const pidStr of Object.keys(state.pieces)){
        const pid = Number(pidStr);
        const owner = state.pieces[pid];
        const p = PTS.find(x => x.id === pid);
        if (!p) continue;

        const shadow = mk('circle', { class:'pieceShadow', cx:p.x, cy:p.y, r:14 });
        const piece  = mk('circle', { class:`piece ${owner}`, cx:p.x, cy:p.y, r:14 });
        piecesG.appendChild(shadow);
        piecesG.appendChild(piece);
      }
    }

    function paintNodeStates(){
      const nodeEls = nodesG.querySelectorAll('.node');
      const selectableSet = new Set();

      if (!state.locked && !state.winner){
        if (state.phase === "placement"){
          if (state.placed[state.current] < 3){
            for (const p of PTS) if (pointEmpty(p.id)) selectableSet.add(p.id);
          }
        } else {
          if (state.selected != null){
            for (const d of selectableDestinations(state.selected)) selectableSet.add(d);
          } else {
            for (const pidStr of Object.keys(state.pieces)){
              const pid = Number(pidStr);
              if (state.pieces[pid] !== state.current) continue;
              if (selectableDestinations(pid).length) selectableSet.add(pid);
            }
          }
        }
      }

      nodeEls.forEach(el => {
        const id = Number(el.getAttribute('data-id'));
        const ring = el.querySelector('.node-ring');
        ring.classList.remove('selectable','selected');

        if (state.selected === id) ring.classList.add('selected');
        else if (selectableSet.has(id)) ring.classList.add('selectable');
      });
    }

    const elTurnName = document.getElementById('turn-name');
    const elTurnDot  = document.getElementById('turn-dot');
    const elPhaseName= document.getElementById('phase-name');
    const elActionHint = document.getElementById('actionHint');
    const elThreeHint  = document.getElementById('threeHint');

    const elP1Name  = document.getElementById('p1-name');
    const elP2Name  = document.getElementById('p2-name');
    const elP1Badge = document.getElementById('p1-badge');
    const elP2Badge = document.getElementById('p2-badge');

    const elTP1Name  = document.getElementById('t-p1-name');
    const elTP2Name  = document.getElementById('t-p2-name');
    const elTP1Badge = document.getElementById('t-p1-badge');
    const elTP2Badge = document.getElementById('t-p2-badge');

    const elRulesShort = document.getElementById('rules-short');
    const elRulesMove  = document.getElementById('rules-move');
    const elRulesWin   = document.getElementById('rules-win');

    const elCardP1 = document.getElementById('card-p1');
    const elCardP2 = document.getElementById('card-p2');
    const elTCardP1 = document.getElementById('t-card-p1');
    const elTCardP2 = document.getElementById('t-card-p2');

    const puckP1 = document.getElementById('p1-pucks');
    const puckP2 = document.getElementById('p2-pucks');
    const puckTP1 = document.getElementById('t-p1-pucks');
    const puckTP2 = document.getElementById('t-p2-pucks');

    function phaseLabel(){
      return state.phase === "placement" ? UI_TEXT.phase_placement : UI_TEXT.phase_movement;
    }

    function updateTurnClasses(){
      document.body.classList.remove('turn-p1','turn-p2');
      document.body.classList.add(state.current === "p1" ? 'turn-p1' : 'turn-p2');

      if (elCardP1) elCardP1.classList.toggle('active', state.current === "p1" && !state.winner);
      if (elCardP2) elCardP2.classList.toggle('active', state.current === "p2" && !state.winner);
      if (elTCardP1) elTCardP1.classList.toggle('active', state.current === "p1" && !state.winner);
      if (elTCardP2) elTCardP2.classList.toggle('active', state.current === "p2" && !state.winner);
    }

    function renderPucks(el, playerId){
      if (!el) return;
      el.innerHTML = "";
      const remaining = Math.max(0, 3 - (state.placed[playerId] || 0));
      for (let i=0;i<3;i++){
        const s = document.createElement('span');
        s.className = "puck " + (i < remaining ? "available " + playerId : "");
        if (i < remaining) s.classList.add(playerId);
        el.appendChild(s);
      }
    }

    function updateTopbar(){
      const turnLabel = state.names[state.current] || (state.current === "p1" ? "Speler 1" : "Speler 2");

      setText(elTurnName, state.winner ? (state.names[state.winner] || turnLabel) : turnLabel);
      setToggle(elTurnDot, 'p1', state.current === "p1");
      setToggle(elTurnDot, 'p2', state.current === "p2");
      setText(elPhaseName, state.winner ? "einde" : phaseLabel());

      setText(elP1Name, state.names.p1);
      setText(elP2Name, state.names.p2);
      setText(elTP1Name, state.names.p1);
      setText(elTP2Name, state.names.p2);

      if (state.phase === "movement"){
        setText(elP1Badge, "3 stukken op bord");
        setText(elP2Badge, "3 stukken op bord");
        setText(elTP1Badge, "3 stukken op bord");
        setText(elTP2Badge, "3 stukken op bord");
      } else {
        setText(elP1Badge, `${3 - state.placed.p1} te plaatsen`);
        setText(elP2Badge, `${3 - state.placed.p2} te plaatsen`);
        setText(elTP1Badge, `${3 - state.placed.p1} te plaatsen`);
        setText(elTP2Badge, `${3 - state.placed.p2} te plaatsen`);
      }

      renderPucks(puckP1, "p1");
      renderPucks(puckP2, "p2");
      renderPucks(puckTP1, "p1");
      renderPucks(puckTP2, "p2");
    }

    function updateHints(){
      if (state.locked && !state.winner){
        setText(elActionHint, "Micro-oefeningen: voltooi de startstappen om te beginnen.");
        setText(elThreeHint, "");
        return;
      }

      if (state.winner){
        setText(elActionHint, `Finis lūdī. Winnaar: ${state.names[state.winner]}.`);
        setText(elThreeHint, UI_TEXT.hint_win);
        return;
      }

      if (state.phase === "placement"){
        setText(elActionHint, UI_TEXT.hint_place);
      } else {
        if (state.selected == null) setText(elActionHint, UI_TEXT.hint_select);
        else setText(elActionHint, UI_TEXT.hint_move);
      }

      setText(elThreeHint, (CFG?.game?.ui_hooks?.show_three_in_row_hint ? UI_TEXT.hint_win : ""));
    }

    function syncRulesBox(){
      const bg = CFG?.game?.background?.short || "";
      const rs = CFG?.game?.background?.rules_summary || {};
      setText(elRulesShort, bg);
      setText(elRulesMove, rs.movement_rule || "—");
      setText(elRulesWin, rs.win_condition || "—");
    }

    function renderAll(){
      const prevPhase = state.phase;

      updatePhase();
      drawPieces();
      paintNodeStates();
      updateTopbar();
      updateTurnClasses();
      updateHints();

      if (!state.winner && prevPhase !== state.phase && state.phase === "movement"){
        setText(elActionHint, "Schuiven: klik op jouw stuk, klik dan op een direct verbonden leeg punt (1 stap).");
      }
    }

    syncRulesBox();
    drawNodes();
    renderAll();

    function onNodeClick(pid){
      if (state.locked) return;
      if (state.winner) return;

      if (state.phase === "placement"){
        const ok = placePiece(pid);
        if (ok){
          renderAll();
          if (checkWinner()) triggerEndSequence();
        }
        return;
      }

      if (state.selected == null){
        if (state.pieces[pid] === state.current && selectableDestinations(pid).length){
          state.selected = pid;
          renderAll();
        }
        return;
      }

      if (pid === state.selected){
        state.selected = null;
        renderAll();
        return;
      }

      if (state.pieces[pid] === state.current && selectableDestinations(pid).length){
        state.selected = pid;
        renderAll();
        return;
      }

      const ok = movePiece(state.selected, pid);
      if (ok){
        renderAll();
        if (checkWinner()) triggerEndSequence();
      } else {
        renderAll();
      }
    }

    const overlay = document.getElementById('overlay');
    const overlayBody = document.getElementById('overlay-body');
    const overlayNext = document.getElementById('overlay-next');
    const overlayStep = document.getElementById('overlay-step');
    const promptTitle = document.getElementById('promptTitle');
    const promptMain  = document.getElementById('promptMain');
    const promptHint  = document.getElementById('promptHint');
    const btnHint     = document.getElementById('btn-hint');
    const overlayNote = document.getElementById('overlay-note');
    const btnAudio    = document.getElementById('btn-audio');

    const btnPractice = document.getElementById('btn-practice');

    let sequence = null;
    let seqIndex = 0;
    let currentDrill = null;
    let hintVisible = false;

    function openOverlay(){
      overlay.classList.add('active');
      overlayNext.focus();
    }
    function closeOverlay(){
      overlay.classList.remove('active');
    }

    function normalizeAnswer(s){
      return String(s || "")
        .trim()
        .replace(/\s+/g, " ")
        .replace(/\s([?.!,;:])/g, "$1")
        .toLowerCase();
    }

    function resetHint(){
      hintVisible = false;
      if (promptHint){
        promptHint.classList.remove('visible');
        promptHint.textContent = "";
      }
    }

    btnHint?.addEventListener('click', () => {
      hintVisible = !hintVisible;
      if (promptHint) promptHint.classList.toggle('visible', hintVisible);
    });

    function setPrompt({title, main, hint, phraseIdForAudio}){
      setText(promptTitle, title || "");
      setText(promptMain, main || "—");
      resetHint();
      if (promptHint) promptHint.textContent = hint || "";

      wireAudioButton(btnAudio, phraseIdForAudio || null);
    }

    function shuffle(arr){
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function buildMcqMatch(phraseId){
      const p = getPhraseById(phraseId);
      const correct = p?.nl || "";
      const pool = (CFG?.latin_learning?.phrases || [])
        .filter(x => x.id !== phraseId)
        .map(x => x.nl || "")
        .filter(Boolean);

      const wrongs = shuffle(pool).slice(0, 3);
      const options = shuffle([correct, ...wrongs]).slice(0, 4);

      const wrap = document.createElement('div');
      wrap.className = "choices";
      let answered = false;

      for (const opt of options){
        const btn = document.createElement('button');
        btn.className = "choice";
        btn.type = "button";
        btn.textContent = opt || "—";
        btn.addEventListener('click', () => {
          if (answered) return;
          answered = true;

          const isCorrect = (opt === correct);
          btn.classList.add(isCorrect ? "correct" : "wrong");

          const prog = loadProgress();
          markSeen(prog, phraseId);
          markResult(prog, phraseId, isCorrect);
          saveProgress(prog);

          setText(overlayNote, isCorrect ? "Correct." : "Onjuist.");
          overlayNext.disabled = false;

          hintVisible = true;
          if (promptHint) promptHint.classList.add('visible');
        });
        wrap.appendChild(btn);
      }
      return wrap;
    }

    function buildTapToConfirm(phraseId){
      const box = document.createElement('div');
      box.className = "phaseBox";
      box.innerHTML = `<b>Bevestig:</b> je herkent de zin.`;

      const prog = loadProgress();
      markSeen(prog, phraseId);
      markResult(prog, phraseId, true);
      saveProgress(prog);

      return box;
    }

    function buildReadAloud(phraseId){
      const wrap = document.createElement('div');
      wrap.className = "phaseBox";

      const p = document.createElement('div');
      p.style.fontWeight = "800";
      p.style.marginBottom = "10px";
      p.textContent = AUDIO_CFG.enabled
        ? "Druk op de luidspreker, spreek na, en bevestig pas daarna."
        : "Lees de zin hardop. Bevestig pas daarna.";

      const row = document.createElement('div');
      row.className = "inputRow";

      const btn = document.createElement('button');
      btn.type = "button";
      btn.className = "btn primary";
      btn.textContent = "Ik heb het hardop gelezen";
      btn.disabled = true;

      const info = document.createElement('div');
      info.className = "note";
      info.textContent = "Wacht even…";

      row.appendChild(btn);
      row.appendChild(info);

      wrap.appendChild(p);
      wrap.appendChild(row);

      overlayNext.disabled = true;
      overlayNote.textContent = "";
      let t = 3;

      (function tick(){
        if (t <= 0){
          info.textContent = "Bevestig wanneer je klaar bent.";
          btn.disabled = false;
          return;
        }
        info.textContent = `Lees hardop. (${t})`;
        t -= 1;
        setTimeout(tick, 900);
      })();

      btn.addEventListener('click', () => {
        const prog = loadProgress();
        markSeen(prog, phraseId);
        markResult(prog, phraseId, true);
        saveProgress(prog);

        overlayNote.textContent = "OK.";
        overlayNext.disabled = false;
      });

      return wrap;
    }

    function buildFillBlankName(){
      const wrap = document.createElement('div');
      wrap.className = "inputRow";

      const i1 = document.createElement('input');
      i1.className = "textInput";
      i1.placeholder = "Naam speler 1";
      i1.autocomplete = "off";

      const i2 = document.createElement('input');
      i2.className = "textInput";
      i2.placeholder = "Naam speler 2";
      i2.autocomplete = "off";

      wrap.appendChild(i1);
      wrap.appendChild(i2);

      setText(overlayNote, "Vul beide namen in.");
      overlayNext.disabled = true;

      function validate(){
        const a = (i1.value || "").trim();
        const b = (i2.value || "").trim();
        overlayNext.disabled = !(a.length >= 1 && b.length >= 1);
      }
      i1.addEventListener('input', validate);
      i2.addEventListener('input', validate);

      wrap.__commit = () => {
        state.names.p1 = (i1.value || "Speler 1").trim();
        state.names.p2 = (i2.value || "Speler 2").trim();
        renderAll();

        const prog = loadProgress();
        markSeen(prog, "mihi_nomen_est");
        markResult(prog, "mihi_nomen_est", true);
        saveProgress(prog);
      };

      return wrap;
    }

    function buildMcqResponse(promptPhraseId, optionsPhraseIds){
      const wrap = document.createElement('div');
      wrap.className = "choices";

      let answered = false;
      const opts = optionsPhraseIds.map(id => getPhraseById(id)).filter(Boolean);
      const items = shuffle(opts).slice(0, 2);

      for (const p of items){
        const btn = document.createElement('button');
        btn.type = "button";
        btn.className = "choice with-audio";
        btn.textContent = "";

        const left = document.createElement('div');
        left.className = "choice-left";
        left.innerHTML = `<b>${escapeHtml(p.latin || "")}</b>`;

        const aud = document.createElement('button');
        aud.type = "button";
        aud.className = "choice-audio";
        aud.innerHTML = AUDIO_ICON_SVG;
        aud.style.display = (AUDIO_CFG.enabled ? "" : "none");

        aud.addEventListener('click', async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          await playAudioUrl(audioUrlForPhraseId(p.id), aud);
        });

        btn.appendChild(left);
        btn.appendChild(aud);

        btn.addEventListener('click', () => {
          if (answered) return;
          answered = true;

          const prog = loadProgress();
          markSeen(prog, promptPhraseId);
          markResult(prog, promptPhraseId, true);
          markSeen(prog, p.id);
          markResult(prog, p.id, true);
          saveProgress(prog);

          btn.classList.add("correct");
          setText(overlayNote, "Antwoord gekozen.");
          overlayNext.disabled = false;

          hintVisible = true;
          if (promptHint) promptHint.classList.add('visible');
        });

        wrap.appendChild(btn);
      }

      overlayNext.disabled = true;
      setText(overlayNote, "Kies een antwoord.");
      return wrap;
    }

    function tokenizeLatin(latin){
      const s = String(latin || "").trim().replace(/\s+/g, " ");
      return s.split(" ").filter(Boolean);
    }

    function buildWordOrder(phraseId){
      const p = getPhraseById(phraseId);
      const tokens = tokenizeLatin(p?.latin || "");
      const answer = normalizeAnswer(p?.latin || "");

      const wrap = document.createElement('div');
      wrap.className = "tilesWrap";

      const target = document.createElement('div');
      target.className = "tileRow tileTarget";
      target.setAttribute('aria-label', 'Jouw antwoord');

      const bank = document.createElement('div');
      bank.className = "tileRow";
      bank.setAttribute('aria-label', 'Woorden');

      const shuffled = shuffle(tokens.map((t, idx) => ({ t, idx })));
      const selected = [];

      function render(){
        target.innerHTML = "";
        bank.innerHTML = "";

        selected.forEach((o, i) => {
          const b = document.createElement('span');
          b.className = "tile";
          b.textContent = o.t;
          b.addEventListener('click', () => {
            selected.splice(i, 1);
            render();
            overlayNext.disabled = true;
            setText(overlayNote, "Bouw de zin.");
          });
          target.appendChild(b);
        });

        for (const o of shuffled){
          const inSel = selected.some(x => x.idx === o.idx);
          const b = document.createElement('span');
          b.className = "tile" + (inSel ? " selected" : "");
          b.textContent = o.t;
          if (!inSel){
            b.addEventListener('click', () => {
              selected.push(o);
              render();

              const current = normalizeAnswer(selected.map(x => x.t).join(" "));
              if (current === answer){
                setText(overlayNote, "Correct.");
                overlayNext.disabled = false;

                const prog = loadProgress();
                markSeen(prog, phraseId);
                markResult(prog, phraseId, true);
                saveProgress(prog);

                hintVisible = true;
                if (promptHint) promptHint.classList.add('visible');
              } else {
                overlayNext.disabled = true;
                setText(overlayNote, "Bouw de zin.");
              }
            });
          }
          bank.appendChild(b);
        }

        if (selected.length === tokens.length){
          const current = normalizeAnswer(selected.map(x => x.t).join(" "));
          if (current !== answer){
            const prog = loadProgress();
            markSeen(prog, phraseId);
            markResult(prog, phraseId, false);
            saveProgress(prog);

            setText(overlayNote, "Onjuist. Gebruik de hint of probeer opnieuw.");
            hintVisible = true;
            if (promptHint) promptHint.classList.add('visible');
          }
        }
      }

      render();
      wrap.appendChild(target);
      wrap.appendChild(bank);
      overlayNext.disabled = true;
      setText(overlayNote, "Bouw de zin.");
      return wrap;
    }

    function runStep(step){
      overlayNext.disabled = true;
      setText(overlayNote, "");
      overlayBody.innerHTML = "";
      currentDrill = null;
      resetHint();

      const phraseId = step?.phrase_id || step?.phraseId || null;
      const drill = step?.drill || {};
      const t = drill.type;

      const total = sequence?.steps?.length || 1;
      const label = `${sequence.labelPrefix} ${seqIndex+1}/${total}`;
      setText(overlayStep, label);

      if (t === "mcq_match"){
        const p = getPhraseById(phraseId);
        setPrompt({ title:"Kies de betekenis", main:p?.latin || "—", hint:p?.nl || "", phraseIdForAudio: phraseId });
        overlayBody.appendChild(buildMcqMatch(phraseId));
        overlayNext.disabled = true;
        setText(overlayNote, "");
        return;
      }

      if (t === "fill_blank_name"){
        const p = getPhraseById("mihi_nomen_est");
        setPrompt({ title:"Vul namen in", main:p?.latin || "—", hint:p?.nl || "", phraseIdForAudio: "mihi_nomen_est" });
        const ui = buildFillBlankName();
        overlayBody.appendChild(ui);
        currentDrill = { type:t, phraseId:"mihi_nomen_est", ui };
        return;
      }

      if (t === "mcq_response"){
        const p = getPhraseById(drill.prompt_phrase_id);
        setPrompt({ title:"Kies een antwoord", main:p?.latin || "—", hint:p?.nl || "", phraseIdForAudio: drill.prompt_phrase_id });
        overlayBody.appendChild(buildMcqResponse(drill.prompt_phrase_id, drill.options_phrase_ids));
        return;
      }

      if (t === "word_order"){
        const p = getPhraseById(phraseId);
        setPrompt({
          title:"Zet de Latijnse woorden in de juiste volgorde",
          main:p?.nl || "—",
          hint:p?.latin || "",
          phraseIdForAudio: phraseId
        });
        overlayBody.appendChild(buildWordOrder(phraseId));
        return;
      }

      if (t === "read_aloud"){
        const p = getPhraseById(phraseId);
        setPrompt({
          title: "Luister en spreek na",
          main: p?.latin || "—",
          hint: p?.nl || "",
          phraseIdForAudio: phraseId
        });
        overlayBody.appendChild(buildReadAloud(phraseId));
        return;
      }

      if (t === "tap_to_confirm"){
        const p = getPhraseById(phraseId);
        setPrompt({ title:"Herken de zin", main:p?.latin || "—", hint:p?.nl || "", phraseIdForAudio: phraseId });
        overlayBody.appendChild(buildTapToConfirm(phraseId));
        overlayNext.disabled = false;
        setText(overlayNote, "Klik op Verder.");
        return;
      }

      const p = getPhraseById(phraseId);
      setPrompt({ title:"Ga verder", main:p?.latin || "—", hint:p?.nl || "", phraseIdForAudio: phraseId });
      overlayBody.appendChild(buildTapToConfirm(phraseId));
      overlayNext.disabled = false;
      setText(overlayNote, "Klik op Verder.");
    }

    function startSequence(seq){
      sequence = seq;
      seqIndex = 0;
      openOverlay();
      runStep(sequence.steps[seqIndex]);
    }

    function finishSequence(){
      closeOverlay();
      sequence = null;
      seqIndex = 0;
      currentDrill = null;
    }

    overlayNext.addEventListener('click', () => {
      if (!sequence) { closeOverlay(); return; }

      if (currentDrill?.type === "fill_blank_name" && currentDrill.ui?.__commit){
        currentDrill.ui.__commit();
        currentDrill = null;
      }

      seqIndex += 1;
      if (seqIndex >= sequence.steps.length){
        finishSequence();

        if (!state.winner && state.locked){
          state.locked = false;
          renderAll();
        }
        return;
      }
      runStep(sequence.steps[seqIndex]);
    });

    document.addEventListener('keydown', (e) => {
      if (!overlay.classList.contains('active')) return;
      if (e.key === 'Escape'){
        if (!state.locked) closeOverlay();
      }
      if (e.key === 'Enter' && !overlayNext.disabled){
        overlayNext.click();
      }
    });

    function buildPreMatchSequence(){
      const steps = CFG?.latin_learning?.ui_integration?.pre_match_sequence?.steps || [];
      return { steps, labelPrefix: UI_TEXT.overlay_gate };
    }

    function buildPostMatchSequence(outcome){
      const stepsDef = CFG?.latin_learning?.ui_integration?.post_match_sequence?.steps || [];
      const steps = [];
      for (const s of stepsDef){
        if (s.phrase_id){
          steps.push({ phrase_id:s.phrase_id, drill:s.drill || { type:"tap_to_confirm" } });
        } else if (s.outcome_branch){
          const branch = s.outcome_branch[outcome];
          if (branch) steps.push({ phrase_id: branch.phrase_id, drill: branch.drill || { type:"mcq_match" } });
        }
      }
      return { steps, labelPrefix: UI_TEXT.overlay_end };
    }

    function triggerEndSequence(){
      if (!state.winner) return;
      state.locked = true;
      renderAll();

      const seq = buildPostMatchSequence("winner");
      startSequence(seq);
    }

    const LAST_PRACTICE_KEY = "rota_last_practice_phrase_v1";
    state.lastPracticePhraseId = localStorage.getItem(LAST_PRACTICE_KEY) || null;

    function pickPracticeCandidate(){
      const progress = loadProgress();
      const phrases = (CFG?.latin_learning?.phrases || []).filter(p => p && p.id);

      if (!phrases.length) return "salve";

      const items = phrases.map(p => {
        const pr = ensurePhraseProgress(progress, p.id);
        const m  = mastery(progress, p.id);
        const bucketW = pr.bucket === "new" ? 0 : (pr.bucket === "learning" ? 1 : 2);
        return { id: p.id, bucketW, seen: pr.seen || 0, m };
      });

      items.sort((a,b) => (a.bucketW - b.bucketW) || (a.seen - b.seen) || (a.m - b.m));

      const minBucket = items[0].bucketW;
      const minSeen   = items[0].seen;

      let cand = items.filter(x => x.bucketW === minBucket && x.seen === minSeen);
      if (cand.length < 2) cand = items.slice(0, Math.min(4, items.length));

      if (state.lastPracticePhraseId && cand.length > 1){
        const filtered = cand.filter(x => x.id !== state.lastPracticePhraseId);
        if (filtered.length) cand = filtered;
      }

      const pick = cand[Math.floor(Math.random() * cand.length)].id;
      state.lastPracticePhraseId = pick;
      try{ localStorage.setItem(LAST_PRACTICE_KEY, pick); }catch(e){}
      return pick;
    }

    btnPractice?.addEventListener('click', () => {
      if (helpModal?.classList.contains('active')) closeHelpModal();

      if (state.drillsUsedThisMatch >= state.maxDrills) return;

      const pid = pickPracticeCandidate();
      const phrase = getPhraseById(pid);

      const progress = loadProgress();
      const m = mastery(progress, pid);
      const canWord = (phrase?.drill_modes || []).includes("word_order");
      const drillType = (canWord && m < 0.6) ? "word_order" : "mcq_match";

      state.drillsUsedThisMatch += 1;

      startSequence({
        steps: [{ phrase_id: pid, drill: { type: drillType, show_english_hint: false } }],
        labelPrefix: UI_TEXT.overlay_practice
      });
    });

    const btnReset = document.getElementById('btn-reset');

    btnReset.addEventListener('click', () => {
      resetState();
      const seq = buildPreMatchSequence();
      startSequence(seq);
    });

    (function boot(){
      resetState();
      const showGate = !!CFG?.game?.ui_hooks?.show_rule_overlay_on_first_launch;
      if (showGate){
        startSequence(buildPreMatchSequence());
      } else {
        state.locked = false;
        renderAll();
      }
    })();
  </script>
</body>
</html>

